---
solution: Campaign Classic
product: campaign
title: メンテナンスのタイプ
description: メンテナンスのタイプ
audience: production
content-type: reference
topic-tags: database-maintenance
translation-type: tm+mt
source-git-commit: 972885c3a38bcd3a260574bacbb3f507e11ae05b
workflow-type: tm+mt
source-wordcount: '494'
ht-degree: 2%

---


# メンテナンスのタイプ{#types-of-maintenance}

## 申し込みの保守 {#application-maintenance}

Adobe Campaignには、次のような特定のデータベース保守タスクをスケジュールできる組み込みワークフローが用意されています。データ **ベースのクリーンアップワークフロー**。 このワークフローでは、次のタスクを実行します。

* 期限切れのレコードの削除、
* 孤立したレコードの削除と期限切れのオブジェクトのステータス再初期化、
* データベース統計の更新。

>[!IMPORTANT]
>
>クリーンアップタスクは、RDBMSレベルのメンテナンス（統計情報の更新を除く）ではなく、主にアプリケーションレベルのメンテナンスに対応しています。 ただし、データベースではメンテナンス操作が必要になります。 データベースのクリーンアップワークフローが正常に実行されても、データベースが最適に調整されているわけではありません。

## 技術保守 {#technical-maintenance}

データベースのクリーンアップワークフローには、データベース保守ツールが含まれていません。メンテナンスを組織するのはあなた次第です。 これを行うには、次のいずれかを実行します。

* データベース管理者と協力して、サードパーティのツール、
* adobe campaignワークフローエンジンを使用して、これらのメンテナンスアクティビティをスケジュールおよび追跡します。

これらの保守手順は定期的に行う必要があり、次の事項が含まれます。

* 頻繁に更新されるテーブルの再インデックス、
* テーブルをコンパクト化/再構築して断片化を回避します。

### メンテナンススケジュール {#maintenance-schedule}

これらのメンテナンスアクティビティを実行するための適切なスロットを探す必要があります。 実行中はデータベースのパフォーマンスに大きな影響を与える場合があり、ロックによってアプリケーションをブロックする場合もあります。

これらのタスクは、通常、バックアップ、データ再読み込み、集計の計算と競合しない低アクティビティの間、週に1回実行されます。 高い頻度で要求されるシステムの中には、より頻繁なメンテナンスが必要なものもあります。

フルテーブルの再構築など、より詳細なメンテナンスは月に1回実行できます。システムが使用できないため、アプリケーションが完全に停止した場合は、可能です。

### テーブルの再構築 {#rebuilding-a-table}

いくつかの方法があります。

<table> 
 <thead> 
  <tr> 
   <th> 操作 </th> 
   <th> 説明 </th> 
   <th> 利点 </th> 
   <th> 欠点 </th> 
  </tr> 
 </thead> 
 <tbody> 
  <tr> 
   <td> オンラインでの最適化<br /> </td> 
   <td> ほとんどのデータベースエンジンは、最適化の方法を備えています。<br /> </td> 
   <td> データベースの最適化方法を使用するだけです。 これらの方法では、通常、最適化の際にデータをロックすることで整合性の問題が発生します。<br /> </td> 
   <td> データベースに応じて、これらのデフラグメンテーション方法はRDBMSオプション(Oracle)として提供され、大きなテーブルを処理する最も効率的な方法ではありません。<br /> </td> 
  </tr> 
  <tr> 
   <td> ダンプとリストア<br /> </td> 
   <td> テーブルをファイルにダンプし、データベース内のテーブルを削除して、ダンプからリストアします。<br /> </td> 
   <td> これは、テーブルの最適化を解除する最も簡単な方法です。 また、データベースがほぼいっぱいになった場合の唯一の解決策です。<br /> </td> 
   <td> テーブルが削除および再作成されるので、読み取り専用モードでも、アプリケーションをオンラインのままにすることはできません（このテーブルは復元フェーズ中は使用できません）。<br /> </td> 
  </tr> 
  <tr> 
   <td> 重複、名前の変更とドロップ<br /> </td> 
   <td> これにより、テーブルとそのインデックスのコピーが作成され、既存のテーブルが削除され、コピーの名前が変更されて代わりに使用されます。<br /> </td> 
   <td> この方法は、IOの生成数が少ない（ファイルとしてコピーせず、このファイルから読み取らない）ため、最初の方法よりも高速です。<br /> </td> 
   <td> 2倍の容量が必要です。<br /> プロセス中にテーブルに書き込むすべてのアクティブなプロセスを停止する必要があります。 ただし、テーブルは再構築された最後の瞬間に入れ替わるので、読み取りプロセスには影響しません。 <br /> </td> 
  </tr> 
 </tbody> 
</table>

