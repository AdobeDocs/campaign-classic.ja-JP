---
title: 統合の設定
seo-title: 統合の設定
description: 統合の設定
seo-description: null
page-status-flag: never-activated
uuid: e2db7bdb-8630-497c-aacf-242734cc0a72
contentOwner: sauviat
products: SG_CAMPAIGN/CLASSIC
audience: integrations
content-type: reference
topic-tags: adobe-experience-manager
discoiquuid: 1c20795d-748c-4f5d-b526-579b36666e8f
translation-type: tm+mt
source-git-commit: d15e953740b0a4dd8073b36fd59b4c4e44906340
workflow-type: tm+mt
source-wordcount: '1273'
ht-degree: 71%

---


# カスタム導入用のイベントの設定 {#events}

この設定の一部はカスタム開発であり、次のものが必要です。

* Adobe Campaign での JSON、XML および JavaScript の解析に関する実務知識
* QueryDef API および Writer API の実務知識
* 秘密鍵を使用した暗号化と認証に関する実務概念

JSコードの編集には技術的なスキルが必要なので、適切な理解が得られないように試みてください。

デフォルトの実装以外で提供されるACXパッケージの一部として、イベントのさらなる処理を行います。 受信したイベントは、JavaScriptコードを使用して即座に処理されます。 これ以上処理をおこなうことなく、リアルタイムにデータベーステーブルに保存されます。
トリガーは、電子メールを送信するキャンペーンワークフローでのターゲティングに使用されます。 キャンペーンは、イベントをトリガーした顧客が電子メールを受信するように設定されます。

## JavaScript でのイベント処理 {#events-javascript}

### JavaScript ファイル {#file-js}

パイプラインでは JavaScript 関数を使用して各メッセージを処理します。この関数はユーザー定義関数です。

これは、「JSConnector」属性の下の **[!UICONTROL NmsPipeline_Config]** オプションで設定します。この JavaScript は、イベントを受信するたびに呼び出されます。[!DNL pipelined] プロセスで実行されます。

サンプルの JS ファイルは、cus:triggers.js です。

### JavaScript 関数 {#function-js}

[!DNL pipelined] JavaScript は、特定の関数で起動する必要があります。

この関数は、イベントごとに 1 回呼び出されます。

```
function processPipelineMessage(xmlTrigger) {}
```

次のように返されます。

```
<undefined/>
```

JSを編集した後、再起動する必要 [!DNL pipelined] があります。

### トリガーデータフォーマット {#trigger-format}

データは、XML形式でJS関数に渡されます。 [!DNL trigger]

* **[!UICONTROL @triggerId]** 属性には [!DNL trigger] の名前が含まれています。
* The **enrichments** element in JSON format contains the data generated by Adobe Analytics and is attached to the trigger.
* **[!UICONTROL @offset]** は、メッセージへの「ポインタ」です。キュー内のメッセージの順序を示します。
* **[!UICONTROL @partition]** は、キュー内のメッセージのコンテナです。 オフセットは、パーティションを基準とした相対値です。<br>キューには約 15 のパーティションがあります。

例：

```
<trigger offset="1500435" partition="4" triggerId="LogoUpload_1_Visits_from_specific_Channel_or_ppp">
 <enrichments>{"analyticsHitSummary":{"dimensions":{" eVar01":{"type":"string","data":["PI4INE1ETDF6UK35GO13X7HO2ITLJHVH"],"name":" eVar01","source":"session summary"}, "timeGMT":{"type":"int","data":[1469164186,1469164195],"name":"timeGMT","source":"session summary"}},"products":{}}}</enrichments>
 <aliases/>
 </trigger>
```

### データ形式エンリッチメント {#enrichment-format}

>[!NOTE]
>
>これは、考えられる様々な実装から得られる具体的な例です。

コンテンツは、各トリガーに対してAdobe AnalyticsでJSON形式で定義されます。
例えば、LogoUpload_uploading_Visits トリガーの場合：

* **[!UICONTROL eVar01]** は、Adobe Campaign受信者との調整に使用するString形式の買い物客IDを含めることができます。 <br>プライマリキーである買い物客 ID を見つけるために紐付ける必要があります。

* **[!UICONTROL timeGMT]** :Adobe Analytics側のトリガーの時刻をUTCエポック形式（01/01/1970 UTCからの秒数）で含めることができます。

例：

```
{
 "analyticsHitSummary": {
 "dimensions": {
 "eVar01": {
 "type": "string",
 "data": ["PI4INE1ETDF6UK35GO13X7HO2ITLJHVH"],
 "name": " eVar01",
 "source": "session summary"
 },
 "timeGMT": {
 "type": "int",
 "data": [1469164186, 1469164195],
 "name": "timeGMT",
 "source": "session summary"
 }
 },
 "products": {}
 }
 }
```

### イベントの処理順序{#order-events}

イベントは、オフセット順に 1 つずつ処理されます。[!DNL pipelined] の各スレッドは異なるパーティションを処理します。

最後に取得したイベントの「オフセット」がデータベースに格納されます。したがって、プロセスが停止すると、最後のメッセージから再開されます。このデータは組み込みスキーマ xtk:pipelineOffset に格納されます。

このポインターは、各インスタンスと各コンシューマーに固有です。したがって、多くのインスタンスが異なるコンシューマーを使用して同じパイプラインにアクセスする場合、すべてのメッセージが同じ順序で取得されます。

The **consumer** parameter of the pipeline option identifies the calling instance.

現在、「staging」や「dev」などの環境ごとに異なるキューを使用する方法はありません。

### ログとエラー処理 {#logging-error-handling}

logInfo() などのログは [!DNL pipelined] ログに送られます。logError() などのエラーは [!DNL pipelined] ログに書き込まれ、エラーの結果、イベントが再試行キューに入れられます。この場合、パイプライン化されたログを確認する必要があります。
エラーのメッセージは、[!DNL pipelined] オプションで設定された時間内に複数回再試行されます。

デバッグおよび監視の目的で、フルトリガーデータが、XML形式の「data」フィールドのトリガーテーブルに書き込まれます。 または、トリガーデータを含んだ logInfo() も同じ目的を果たします。

### データの解析 {#data-parsing}

このサンプル JS コードは、エンリッチメント内の eVar01 を解析します。

```
function processPipelineMessage(xmlTrigger)
 {
 (…)
 var shopper_id = ""
 if (xmlTrigger.enrichments.length() > 0)
 {
 if (xmlTrigger.enrichments.toString().match(/eVar01/) != undefined)
 {
 var enrichments = JSON.parse(xmlTrigger.enrichments.toString())
 shopper_id = enrichments.analyticsHitSummary.dimensions. eVar01.data[0]
 }
 }
 (…)
 }
```

エラーを避けるために、解析をおこなう場合は注意が必要です。
このコードはすべてのトリガーに使用されるので、ほとんどのデータは不要です。したがって、存在しない場合は空のままにすることができます。

### トリガーの保存 {#storing-triggers-js}

>[!NOTE]
>
>これは、考えられる様々な実装から得られる具体的な例です。

このサンプル JS コードは、トリガーをデータベースに保存します。

```
function processPipelineMessage(xmlTrigger)
 {
 (…)
 var event = 
 <pipelineEvent
 xtkschema = "cus:pipelineEvent"
 _operation = "insert"
 created = {timeNow}
 lastModified = {timeNow}
 triggerType = {triggerType}
 timeGMT = {timeGMT}
 shopper_id = {shopper_id}
 data = {xmlTrigger.toXMLString()}
 />
 xtk.session.Write(event)
 return <undef/>;
 }
```

### 制約 {#constraints}

このコードは高周波数で実行され、他のマーケティングアクティビティに悪影響を及ぼす可能性があるので、このコードのパフォーマンスは最適である必要があります。 特に、マーケティングサーバーで1時間に100万を超えるトリガーイベントを処理する場合、または適切に調整されない場合に使用します。

この JavaScript のコンテキストは制限されています。API のすべての機能を使用できるわけではありません。例えば、getOption() や getCurrentdate() は機能しません。

処理を高速化するために、このスクリプトの複数のスレッドが同時に実行されます。コードはスレッドセーフにする必要があります。

## イベントの保存 {#store-events}

>[!NOTE]
>
>これは、考えられる様々な実装から得られる具体的な例です。

### パイプラインイベントスキーマ {#pipeline-event-schema}

イベントは、データベーステーブルに保存されます。このメソッドは、ターゲット顧客に対するマーケティングキャンペーンや、トリガーを使用した電子メールの拡充に使用されます。
トリガーごとに異なるデータ構造にすることができますが、すべてのトリガーを 1 つのテーブルに保持できます。
triggerType フィールドは、データの発生元となるトリガーを識別します。

このテーブルのサンプルスキーマコードを以下に示します。

| 属性 | タイプ | ラベル | 説明 |
|:-:|:-:|:-:|:-:|
| pipelineEventId | 長いテキスト | プライマリキー | トリガーの内部プライマリキー。 |
| data | メモ | トリガーデータ | XML 形式で記述したトリガーデータの完全な内容。デバッグおよび監査のために使用します。 |
| triggerType | 50 バイト長文字列 | TriggerType | トリガーの名前。Web サイトでの顧客の行動を識別します。 |
| shopper_id | 32 バイト長文字列 | shopper_id | 買い物客の内部識別子。紐付けワークフローで設定されます。0 の場合、Campaign で顧客が不明であることを意味します。 |
| shopper_key | 長いテキスト | shopper_key | Analytics でキャプチャされた、買い物客の外部識別子。 |
| created | 日時 | 作成日時 | イベントが Campaign で作成された日時。 |
| lastModified | 日時 | 最終変更日時 | イベントがアドビで最後に変更された日時。 |
| timeGMT | 日時 | タイムスタンプ | イベントが Analytics で生成された時刻。 |

### イベントの表示 {#display-events}

イベントは、イベントスキーマに基づいてシンプルなフォームで表示できます。

>[!NOTE]
>
>パイプラインイベントノードは組み込まれておらず、追加する必要があります。また、関連フォームも Campaign で作成する必要があります。これらの操作は、エキスパートユーザーのみに制限されます。この点について詳しくは、[ナビゲーション階層](../../configuration/using/about-navigation-hierarchy.md)および[フォームの編集](../../configuration/using/editing-forms.md)の節を参照してください。

![](assets/triggers_7.png)

## イベントの処理 {#processing-the-events}

### 紐付けワークフロー {#reconciliation-workflow}

調整とは、顧客をAdobe AnalyticsからAdobe Campaignデータベースに照合するプロセスです。 例えば、shopper_id を照合の条件にすることができます。

パフォーマンス上の理由から、照合はワークフローでバッチモードでおこなう必要があります。
ワークロードを最適化するには、頻度を 15 分に設定する必要があります。その結果、Adobe Campaign でのイベントの受信とマーケティングワークフローによる処理との間の遅延は、最大 15 分になります。

### JavaScript での単位紐付けのオプション {#options-unit-reconciliation}

JavaScriptの各トリガーに対して調整クエリを実行できます。 パフォーマンスが高くなる効果があり、結果が出るのが速くなります。高い反応度が必要な場合、これが特定のユースケースに必要になることがあります。

shopper_idにインデックスが設定されていない場合は、導入が難しい場合があります。 条件がマーケティングサーバーとは別のデータベースサーバー上にある場合は、データベースリンクが使用されますが、パフォーマンスが低下します。

### ワークフローのパージ {#purge-workflow}

トリガーは1時間以内に処理されます。 トリガーの量は 1 時間あたり約 100 万個になることがあります。だからこそ、パージワークフローを用意する必要があるのです。削除は1日に1回実行され、3日を超えるすべてのトリガーが削除されます。

### キャンペーンワークフロー {#campaign-workflow}

トリガーキャンペーンワークフローは、多くの場合、使用されたことがある他の繰り返しキャンペーンと似ています。
例えば、トリガーに関するクエリで開始し、最終日の特定のイベントを探すことができます。そのターゲットは E メールの送信に使用されます。エンリッチメントやデータはトリガーから得られます。設定が不要なので、マーケティングで安全に使用できます。
